"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[3613],{12492:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>h});var i=a(85893),s=a(11151);const n={title:"Light Halos",tags:["lighting"],thumb:"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/406040/2TX0AO-image-75.jpg"},o=void 0,r={id:"tutorials/light-halos",title:"Light Halos",description:"Find out more by forking the full project.",source:"@site/docs/tutorials/light-halos.md",sourceDirName:"tutorials",slug:"/tutorials/light-halos",permalink:"/tutorials/light-halos",draft:!1,unlisted:!1,editUrl:"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/tutorials/light-halos.md",tags:[{label:"lighting",permalink:"/tags/lighting"}],version:"current",frontMatter:{title:"Light Halos",tags:["lighting"],thumb:"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/406040/2TX0AO-image-75.jpg"},sidebar:"tutorialsSidebar",previous:{title:"Light Cookies",permalink:"/tutorials/light-cookies"},next:{title:"Load assets with a progress bar",permalink:"/tutorials/load-assets-with-a-progress-bar"}},l={},h=[{value:"Assets",id:"assets",level:2},{value:"Texture",id:"texture",level:3},{value:"Material",id:"material",level:3},{value:"Entities",id:"entities",level:2},{value:"Code",id:"code",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("div",{className:"iframe-container",children:(0,i.jsx)("iframe",{loading:"lazy",src:"https://playcanv.as/p/rnIUbXws/",title:"Light Halos"})}),"\n",(0,i.jsxs)(t.p,{children:["Find out more by forking the ",(0,i.jsx)(t.a,{href:"https://playcanvas.com/project/406040",children:"full project"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This simple effect is great for adding atmosphere to your scene. Add a glow to a light source or an emissive texture to give the effect of a dusty or foggy atmosphere or simulate the effect of looking at a bright light."}),"\n",(0,i.jsx)(t.p,{children:"It works like this: We create an entity with a plane primitive attached which has a glowing halo material on it. We attach a script to entity which makes the plane always face the camera (billboarding). For added fun, we're fading the halo out if it faces away from the camera to simulate a directional light."}),"\n",(0,i.jsx)(t.h2,{id:"assets",children:"Assets"}),"\n",(0,i.jsx)(t.h3,{id:"texture",children:"Texture"}),"\n",(0,i.jsx)(t.p,{children:"First you'll need a halo texture. In this example we've just used a very simple blurred blob that was created in a art program like Photoshop."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"/images/tutorials/intermediate/light-halos/blob.jpg",alt:"blob"})}),"\n",(0,i.jsx)(t.p,{children:"This texture will form the basis of the glow."}),"\n",(0,i.jsx)(t.h3,{id:"material",children:"Material"}),"\n",(0,i.jsx)("img",{loading:"lazy",src:"/images/tutorials/intermediate/light-halos/material.png",height:"600"}),"\n",(0,i.jsxs)(t.p,{children:["The material for the light halo uses the blob texture in the emissive slot. Use the ",(0,i.jsx)(t.strong,{children:"tint"})," property to set the color of your halo. We've also enabled blending in the Opacity slot and it also uses the blob texture with ",(0,i.jsx)(t.strong,{children:"Color Channel"})," set to ",(0,i.jsx)(t.strong,{children:"R"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"Blend Type"})," is set to ",(0,i.jsx)(t.strong,{children:"Additive Alpha"}),". The ",(0,i.jsx)(t.strong,{children:"Additive"})," part means that the color of the material is added to the color of background underneath it. This means the halo glows against the background. The ",(0,i.jsx)(t.strong,{children:"Alpha"})," part means it uses the value of the ",(0,i.jsx)(t.code,{children:"opacity"})," to set how transparent the material is."]}),"\n",(0,i.jsx)(t.h2,{id:"entities",children:"Entities"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"/images/tutorials/intermediate/light-halos/entity-setup.jpg",alt:"entities"})}),"\n",(0,i.jsxs)(t.p,{children:["The Entity setup for the glow is simple too. We have a parent Entity for the halo script and a child Entity which has the plane primitive attached to it. The reason we do this is to simplify the code so that we can use ",(0,i.jsx)(t.code,{children:"entity.lookAt"})," to set the orientation of the glow. The Plane primitive faces upwards so we create a child entity and apply a rotation to this child so that the plane is correctly positioned facing the camera."]}),"\n",(0,i.jsx)(t.h2,{id:"code",children:"Code"}),"\n",(0,i.jsx)(t.p,{children:"The code for this project has two particularly interesting features."}),"\n",(0,i.jsx)(t.p,{children:"First, we update the halo entity to face the camera every frame"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"// Set the glow to always face the camera\nthis.entity.lookAt(this.camera.getPosition());\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Second, if the halo is marked as ",(0,i.jsx)(t.code,{children:"unidirectional"})," (with a script attribute that we've exposed), then we modify the opacity so that the halo is invisible when it is facing away from the camera. In fact we slowly modify the opacity so that it gets more transparent the more it points away from the camera."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'// If enabled, unidirectional means the glow fades off as it turns away from the camera\nif (this.unidirectional) {\n    // Get the dot product of the parent direction and the camera direction\n    var dot = -1 * tmp.dot(this.camera.forward);\n    // If the dot product is less that 0 the glow is facing away from the camera\n    if (dot < 0) {\n        dot = 0;\n    }\n\n    // Override the opacity value on the planes mesh instance to fade to zero as the glow turns away from the camera\n    meshes[0].setParameter("material_opacity", dot);\n} else {\n    // Need to set a default value because of this issue for now: https://github.com/playcanvas/engine/issues/453\n    meshes[0].setParameter("material_opacity", 1);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We're using the ",(0,i.jsx)(t.code,{children:"setParameter"})," method on the ",(0,i.jsx)(t.a,{href:"https://api.playcanvas.com/classes/Engine.MeshInstance.html",children:"pc.MeshInstance"})," to set a value for the fragment shader to use. This is currently an undocumented feature in the engine (you won't find it on the link to the developer docs). The reason for this is because it relies on knowing exactly the name of the uniform variable in the shader. These values might change and this API might change in the future. But it's pretty useful, because it let's you override a single value in a shader just for that mesh instance. In this case, it's important because all the glows use the same material, but we will want a different value for the opacity for each instance of the glow."]}),"\n",(0,i.jsx)(t.p,{children:"Here's the complete listing:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"var Halo = pc.createScript('halo');\n\nHalo.attributes.add('camera', {type: 'entity'});\nHalo.attributes.add('unidirectional', {type: 'boolean', default: false});\n\nHalo.tmp = new pc.Vec3();\n\n// initialize code called once per entity\nHalo.prototype.initialize = function() {\n    // Get the Entity with the plane model on it\n    this.plane = this.entity.children[0];\n\n    // Get the parent entity which is used for direction\n    this.parent = this.entity.parent;\n};\n\n// update code called every frame\nHalo.prototype.update = function(dt) {\n    var tmp = Halo.tmp;\n\n    // Store the vector the parent is facing (note forwards is negative z)\n    tmp.copy(this.parent.forward).scale(-1);\n\n    var meshes = this.plane.render.meshInstances;\n\n    if (this.camera) {\n\n        // Set the glow to always face the camera\n        this.entity.lookAt(this.camera.getPosition());\n\n        // If enabled, unidirectional means the glow fades off as it turns away from the camera\n        if (this.unidirectional) {\n            // Get the dot product of the parent direction and the camera direction\n            var dot = -1 * tmp.dot(this.camera.forward);\n            // If the dot product is less that 0 the glow is facing away from the camera\n            if (dot < 0) {\n                dot = 0;\n            }\n\n            // Override the opacity value on the planes mesh instance to fade to zero as the glow turns away from the camera\n            meshes[0].setParameter(\"material_opacity\", dot);\n        } else {\n            // Need to set a default value because of this issue for now: https://github.com/playcanvas/engine/issues/453\n            meshes[0].setParameter(\"material_opacity\", 1);\n        }\n    }\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That's it. A simple but pretty effect to add to your scene. Take a look at the ",(0,i.jsx)(t.a,{href:"https://playcanvas.com/project/406040",children:"project"})," for more information."]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>r,a:()=>o});var i=a(67294);const s={},n=i.createContext(s);function o(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);